TODO:
    - Read from file
    - Check this is still true: Ω segfaults (with a collossal stack of ~35k frames)
    - lhs/rhs reduction order can be changed to reduce wasted steps?
        For alpha only reduce when required: https://en.wikipedia.org/wiki/Lambda_calculus#Capture-avoiding_substitutions
        For beta reduce anything about to be substituted first
        Do this to such an extent that each line of :debug output is a useful
            transformation, use to make seperate :trace command. :trace would be
            invaluable if a bug is discovered in reduction.

Test:
    - (((\x.(\y.(x (x y)))) (\x.y)) z) => y
    - ((\x.(x y)) (\x.x)) => y
    - ((λf.f) (λf.(f f))) => (λf.(f f))
    - (((\x.(\y.(\f.((f x) y)))) a) b) => (λ4.((4 a) b))
    - ((\x.(x (\y.(\z.y)))) (((\x.(\y.(\f.((f x) y)))) a) b)) => a
    - ((\x.(x (\y.(\z.z)))) (((\x.(\y.(\f.((f x) y)))) a) b)) => b

Useful Terms:
    Name        Usage           Term
    - Pair      ((P x) y)       (\x.(\y.(\f.((f x) y))))
    - First     (F ((P x) y))   (\p.(p (\x.(\y.x))))
    - Second    (S ((P x) y))   (\p.(p (\x.(\y.y))))

Usage:
    - Enter one term, press enter for it to be reduced.

Syntax:
    [a-z]+      is a λ-term called a variable
    (λx.y)      is a λ-term called an abstraction iif x is a variable and y is a λ-term
    (x y)       is a λ-term called an application iif x and y are λ-terms
    
    L and \ may be used inplace of λ if one desires. One may mix these symbols
      for λ as one desires. Thus the following is a λ-term:
      (λx.(Ly.(\z.(y (x z)))))

The following are not lambda terms but are recognised by the REPL:
    :quit       This has the effect of quitting the REPL.
    :debug      This toggles debug mode. Debug mode prints reduction information

Sugar:
    None at present. Will implement sugar for all above useful terms, and
    currying.

Present features implemented:
    - α-Reduction
    - β-Reduction
    - Debug mode

Planned features:
    - cons, car, cdr, map, fold
    - No stack-depth limit, rather the limit is the available memory.
        - See Application::betaReduce recursively β-reducing the lhs and rhs
        - Walk the AST without recursion
    - Line editing and history, maybe via GNU readline
    - Sugar currying to accept (λx y.(y x))
    - Church numerals
    - successor/predessessor
    - +/-
    - *//
    - Recursion via Y-Combinator
    - Sugar equivilent to LISPs let

Limits:
    2^64 variables IDs, aborts on exceeding this limit
    Recursion depth is limited by available memory, due to this trying to
        β-reduce Ω is a very bad idea.
