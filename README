TODO:
    - ω segfaults before? running out of memory.
        ((λf.(f f)) (λf.(f f)))
    - lhs/rhs reduction order can be changed to reduce wasted steps?

Test:
    - (((\x.(\y.(x (x y)))) (\x.y)) z) => y

Usage:
    - Enter one term, press enter for it to be reduced.

Syntax:
    [a-z]+      is a λ-term called a variable
    (λx.y)      is a λ-term called an abstraction iif x and y are λ-terms
    (x y)       is a λ-term called an application iif x and y are λ-terms
    
    L and \ may be used inplace of λ if one desires. One may mix these symbols
      for λ as one desires. Thus the following is a λ-term:
      (λx.(Ly.(\z.(y (x z)))))

The following are not lambda terms but are recognised by the REPL:
    :quit       This has the effect of quitting the REPL.

Sugar:
    None at present.

Present features implemented:
    - No stack-depth limit, rather the limit is the available memory.
    - α-Reduction
    - β-Reduction

Planned features:
    - Line editing and history, maybe via readline
    - Sugar currying to accept λx y.(y x)
    - Sugar equivilent to LISPs let
    - Recursion via Y-Combinator

Limits:
    2^64 variables IDs, aborts on exceeding this limit
    Recursion depth is limited by available memory, due to this trying to
        β-reduce ω is a very bad idea.
