TODO:
    - ω segfaults
    - lhs/rhs reduction order can be changed to reduce wasted steps?

Test:
    - (((\x.(\y.(x (x y)))) (\x.y)) z) => y
    - ((λf.f) (λf.(f f))) => (λf.(f f))

Usage:
    - Enter one term, press enter for it to be reduced.

Syntax:
    [a-z]+      is a λ-term called a variable
    (λx.y)      is a λ-term called an abstraction iif x and y are λ-terms
    (x y)       is a λ-term called an application iif x and y are λ-terms
    
    L and \ may be used inplace of λ if one desires. One may mix these symbols
      for λ as one desires. Thus the following is a λ-term:
      (λx.(Ly.(\z.(y (x z)))))

The following are not lambda terms but are recognised by the REPL:
    :quit       This has the effect of quitting the REPL.
    :debug      This toggles debug mode. Debug mode prints reduction information

Sugar:
    None at present.

Present features implemented:
    - α-Reduction
    - β-Reduction
    - Debug mode

Planned features:
    - No stack-depth limit, rather the limit is the available memory.
        - See Application::betaReduce recursively β-reducing the lhs and rhs
        - Walk the AST without recursion
    - Line editing and history, maybe via GNU readline
    - Sugar currying to accept λx y.(y x)
    - Sugar equivilent to LISPs let
    - Recursion via Y-Combinator

Limits:
    2^64 variables IDs, aborts on exceeding this limit
    Recursion depth is limited by available memory, due to this trying to
        β-reduce ω is a very bad idea.
