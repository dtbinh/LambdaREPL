TODO:
    - The term (((\x.(\y.(x (x y)))) (\x.y)) z) is β-reduced to
        ((λ3.y) ((λ3.y) z)) and no further.
        
        Futhermore reducing the original term segfaults on a second pass of
            β-reduction.
        
        There is also two seperate variables with the same name, which ought to
            have either been α-reduced away or β-reduced to the same term.
        
        Entering ((λx.y) ((λx.y) z)) does actually reduce to y, as expected.
    - ω segfaults before? running out of memory.
        ((λf.(f f)) (λf.(f f)))

Usage:
    - Enter one term, press enter for it to be reduced.

Syntax:
    [a-z]+      is a λ-term called a variable
    (λx.y)      is a λ-term called an abstraction iif x and y are λ-terms
    (x y)       is a λ-term called an application iif x and y are λ-terms
    
    L and \ may be used inplace of λ if one desires. One may mix these symbols
      for λ as one desires. Thus the following is a λ-term:
      (λx.(Ly.(\z.(y (x z)))))

The following are not lambda terms but are recognised by the REPL:
    :quit       This has the effect of quitting the REPL.

Sugar:
    None at present.

Present features implemented:
    - No stack-depth limit, rather the limit is the available memory.
    - α-Reduction
    - β-Reduction

Planned features:
    - Line editing and history, maybe via readline
    - Sugar currying to accept λx y.(y x)
    - Sugar equivilent to LISPs let
    - Recursion via Y-Combinator

Limits:
    2^64 variables IDs, aborts on exceeding this limit
    Recursion depth is limited by available memory, due to this trying to
        β-reduce ω is a very bad idea.
